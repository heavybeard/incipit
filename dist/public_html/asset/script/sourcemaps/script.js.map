{"version":3,"sources":["_picturefill.js","_lazysizes.js","_zoom.js","_async-style.js","script.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7+CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"script.js","sourcesContent":["/**\r\n * PICTUREFILL\r\n * @description Add IE compatibility for picture html tag\r\n * @see https://scottjehl.github.io/picturefill/\r\n */\r\n\r\n/*! Picturefill - v3.0.1 - 2015-09-30\r\n * http://scottjehl.github.io/picturefill\r\n * Copyright (c) 2015 https://github.com/scottjehl/picturefill/blob/master/Authors.txt; Licensed MIT\r\n */\r\n/*! Gecko-Picture - v1.0\r\n * https://github.com/scottjehl/picturefill/tree/3.0/src/plugins/gecko-picture\r\n * Firefox's early picture implementation (prior to FF41) is static and does\r\n * not react to viewport changes. This tiny module fixes this.\r\n */\r\n(function(window) {\r\n    /*jshint eqnull:true */\r\n    var ua = navigator.userAgent;\r\n\r\n    if ( window.HTMLPictureElement && ((/ecko/).test(ua) && ua.match(/rv\\:(\\d+)/) && RegExp.$1 < 41) ) {\r\n        addEventListener(\"resize\", (function() {\r\n            var timer;\r\n\r\n            var dummySrc = document.createElement(\"source\");\r\n\r\n            var fixRespimg = function(img) {\r\n                var source, sizes;\r\n                var picture = img.parentNode;\r\n\r\n                if (picture.nodeName.toUpperCase() === \"PICTURE\") {\r\n                    source = dummySrc.cloneNode();\r\n\r\n                    picture.insertBefore(source, picture.firstElementChild);\r\n                    setTimeout(function() {\r\n                        picture.removeChild(source);\r\n                    });\r\n                } else if (!img._pfLastSize || img.offsetWidth > img._pfLastSize) {\r\n                    img._pfLastSize = img.offsetWidth;\r\n                    sizes = img.sizes;\r\n                    img.sizes += \",100vw\";\r\n                    setTimeout(function() {\r\n                        img.sizes = sizes;\r\n                    });\r\n                }\r\n            };\r\n\r\n            var findPictureImgs = function() {\r\n                var i;\r\n                var imgs = document.querySelectorAll(\"picture > img, img[srcset][sizes]\");\r\n                for (i = 0; i < imgs.length; i++) {\r\n                    fixRespimg(imgs[i]);\r\n                }\r\n            };\r\n            var onResize = function() {\r\n                clearTimeout(timer);\r\n                timer = setTimeout(findPictureImgs, 99);\r\n            };\r\n            var mq = window.matchMedia && matchMedia(\"(orientation: landscape)\");\r\n            var init = function() {\r\n                onResize();\r\n\r\n                if (mq && mq.addListener) {\r\n                    mq.addListener(onResize);\r\n                }\r\n            };\r\n\r\n            dummySrc.srcset = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\r\n\r\n            if (/^[c|i]|d$/.test(document.readyState || \"\")) {\r\n                init();\r\n            } else {\r\n                document.addEventListener(\"DOMContentLoaded\", init);\r\n            }\r\n\r\n            return onResize;\r\n        })());\r\n    }\r\n})(window);\r\n\r\n/*! Picturefill - v3.0.1\r\n * http://scottjehl.github.io/picturefill\r\n * Copyright (c) 2015 https://github.com/scottjehl/picturefill/blob/master/Authors.txt;\r\n *  License: MIT\r\n */\r\n\r\n(function( window, document, undefined ) {\r\n    // Enable strict mode\r\n    \"use strict\";\r\n\r\n    // HTML shim|v it for old IE (IE9 will still need the HTML video tag workaround)\r\n    document.createElement( \"picture\" );\r\n\r\n    var warn, eminpx, alwaysCheckWDescriptor, evalId;\r\n    // local object for method references and testing exposure\r\n    var pf = {};\r\n    var noop = function() {};\r\n    var image = document.createElement( \"img\" );\r\n    var getImgAttr = image.getAttribute;\r\n    var setImgAttr = image.setAttribute;\r\n    var removeImgAttr = image.removeAttribute;\r\n    var docElem = document.documentElement;\r\n    var types = {};\r\n    var cfg = {\r\n        //resource selection:\r\n        algorithm: \"\"\r\n    };\r\n    var srcAttr = \"data-pfsrc\";\r\n    var srcsetAttr = srcAttr + \"set\";\r\n    // ua sniffing is done for undetectable img loading features,\r\n    // to do some non crucial perf optimizations\r\n    var ua = navigator.userAgent;\r\n    var supportAbort = (/rident/).test(ua) || ((/ecko/).test(ua) && ua.match(/rv\\:(\\d+)/) && RegExp.$1 > 35 );\r\n    var curSrcProp = \"currentSrc\";\r\n    var regWDesc = /\\s+\\+?\\d+(e\\d+)?w/;\r\n    var regSize = /(\\([^)]+\\))?\\s*(.+)/;\r\n    var setOptions = window.picturefillCFG;\r\n    /**\r\n     * Shortcut property for https://w3c.github.io/webappsec/specs/mixedcontent/#restricts-mixed-content ( for easy overriding in tests )\r\n     */\r\n    // baseStyle also used by getEmValue (i.e.: width: 1em is important)\r\n    var baseStyle = \"position:absolute;left:0;visibility:hidden;display:block;padding:0;border:none;font-size:1em;width:1em;overflow:hidden;clip:rect(0px, 0px, 0px, 0px)\";\r\n    var fsCss = \"font-size:100%!important;\";\r\n    var isVwDirty = true;\r\n\r\n    var cssCache = {};\r\n    var sizeLengthCache = {};\r\n    var DPR = window.devicePixelRatio;\r\n    var units = {\r\n        px: 1,\r\n        \"in\": 96\r\n    };\r\n    var anchor = document.createElement( \"a\" );\r\n    /**\r\n     * alreadyRun flag used for setOptions. is it true setOptions will reevaluate\r\n     * @type {boolean}\r\n     */\r\n    var alreadyRun = false;\r\n\r\n    // Reusable, non-\"g\" Regexes\r\n\r\n    // (Don't use \\s, to avoid matching non-breaking space.)\r\n    var regexLeadingSpaces = /^[ \\t\\n\\r\\u000c]+/,\r\n        regexLeadingCommasOrSpaces = /^[, \\t\\n\\r\\u000c]+/,\r\n        regexLeadingNotSpaces = /^[^ \\t\\n\\r\\u000c]+/,\r\n        regexTrailingCommas = /[,]+$/,\r\n        regexNonNegativeInteger = /^\\d+$/,\r\n\r\n        // ( Positive or negative or unsigned integers or decimals, without or without exponents.\r\n        // Must include at least one digit.\r\n        // According to spec tests any decimal point must be followed by a digit.\r\n        // No leading plus sign is allowed.)\r\n        // https://html.spec.whatwg.org/multipage/infrastructure.html#valid-floating-point-number\r\n        regexFloatingPoint = /^-?(?:[0-9]+|[0-9]*\\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/;\r\n\r\n    var on = function(obj, evt, fn, capture) {\r\n        if ( obj.addEventListener ) {\r\n            obj.addEventListener(evt, fn, capture || false);\r\n        } else if ( obj.attachEvent ) {\r\n            obj.attachEvent( \"on\" + evt, fn);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * simple memoize function:\r\n     */\r\n\r\n    var memoize = function(fn) {\r\n        var cache = {};\r\n        return function(input) {\r\n            if ( !(input in cache) ) {\r\n                cache[ input ] = fn(input);\r\n            }\r\n            return cache[ input ];\r\n        };\r\n    };\r\n\r\n    // UTILITY FUNCTIONS\r\n\r\n    // Manual is faster than RegEx\r\n    // http://jsperf.com/whitespace-character/5\r\n    function isSpace(c) {\r\n        return (c === \"\\u0020\" || // space\r\n                c === \"\\u0009\" || // horizontal tab\r\n                c === \"\\u000A\" || // new line\r\n                c === \"\\u000C\" || // form feed\r\n                c === \"\\u000D\");  // carriage return\r\n    }\r\n\r\n    /**\r\n     * gets a mediaquery and returns a boolean or gets a css length and returns a number\r\n     * @param css mediaqueries or css length\r\n     * @returns {boolean|number}\r\n     *\r\n     * based on: https://gist.github.com/jonathantneal/db4f77009b155f083738\r\n     */\r\n    var evalCSS = (function() {\r\n\r\n        var regLength = /^([\\d\\.]+)(em|vw|px)$/;\r\n        var replace = function() {\r\n            var args = arguments, index = 0, string = args[0];\r\n            while (++index in args) {\r\n                string = string.replace(args[index], args[++index]);\r\n            }\r\n            return string;\r\n        };\r\n\r\n        var buildStr = memoize(function(css) {\r\n\r\n            return \"return \" + replace((css || \"\").toLowerCase(),\r\n                // interpret `and`\r\n                /\\band\\b/g, \"&&\",\r\n\r\n                // interpret `,`\r\n                /,/g, \"||\",\r\n\r\n                // interpret `min-` as >=\r\n                /min-([a-z-\\s]+):/g, \"e.$1>=\",\r\n\r\n                // interpret `max-` as <=\r\n                /max-([a-z-\\s]+):/g, \"e.$1<=\",\r\n\r\n                //calc value\r\n                /calc([^)]+)/g, \"($1)\",\r\n\r\n                // interpret css values\r\n                /(\\d+[\\.]*[\\d]*)([a-z]+)/g, \"($1 * e.$2)\",\r\n                //make eval less evil\r\n                /^(?!(e.[a-z]|[0-9\\.&=|><\\+\\-\\*\\(\\)\\/])).*/ig, \"\"\r\n            ) + \";\";\r\n        });\r\n\r\n        return function(css, length) {\r\n            var parsedLength;\r\n            if (!(css in cssCache)) {\r\n                cssCache[css] = false;\r\n                if (length && (parsedLength = css.match( regLength ))) {\r\n                    cssCache[css] = parsedLength[ 1 ] * units[parsedLength[ 2 ]];\r\n                } else {\r\n                    /*jshint evil:true */\r\n                    try{\r\n                        cssCache[css] = new Function(\"e\", buildStr(css))(units);\r\n                    } catch(e) {}\r\n                    /*jshint evil:false */\r\n                }\r\n            }\r\n            return cssCache[css];\r\n        };\r\n    })();\r\n\r\n    var setResolution = function( candidate, sizesattr ) {\r\n        if ( candidate.w ) { // h = means height: || descriptor.type === 'h' do not handle yet...\r\n            candidate.cWidth = pf.calcListLength( sizesattr || \"100vw\" );\r\n            candidate.res = candidate.w / candidate.cWidth ;\r\n        } else {\r\n            candidate.res = candidate.d;\r\n        }\r\n        return candidate;\r\n    };\r\n\r\n    /**\r\n     *\r\n     * @param opt\r\n     */\r\n    var picturefill = function( opt ) {\r\n        var elements, i, plen;\r\n\r\n        var options = opt || {};\r\n\r\n        if ( options.elements && options.elements.nodeType === 1 ) {\r\n            if ( options.elements.nodeName.toUpperCase() === \"IMG\" ) {\r\n                options.elements =  [ options.elements ];\r\n            } else {\r\n                options.context = options.elements;\r\n                options.elements =  null;\r\n            }\r\n        }\r\n\r\n        elements = options.elements || pf.qsa( (options.context || document), ( options.reevaluate || options.reselect ) ? pf.sel : pf.selShort );\r\n\r\n        if ( (plen = elements.length) ) {\r\n\r\n            pf.setupRun( options );\r\n            alreadyRun = true;\r\n\r\n            // Loop through all elements\r\n            for ( i = 0; i < plen; i++ ) {\r\n                pf.fillImg(elements[ i ], options);\r\n            }\r\n\r\n            pf.teardownRun( options );\r\n        }\r\n    };\r\n\r\n    /**\r\n     * outputs a warning for the developer\r\n     * @param {message}\r\n     * @type {Function}\r\n     */\r\n    warn = ( window.console && console.warn ) ?\r\n        function( message ) {\r\n            console.warn( message );\r\n        } :\r\n        noop\r\n    ;\r\n\r\n    if ( !(curSrcProp in image) ) {\r\n        curSrcProp = \"src\";\r\n    }\r\n\r\n    // Add support for standard mime types.\r\n    types[ \"image/jpeg\" ] = true;\r\n    types[ \"image/gif\" ] = true;\r\n    types[ \"image/png\" ] = true;\r\n\r\n    function detectTypeSupport( type, typeUri ) {\r\n        // based on Modernizr's lossless img-webp test\r\n        // note: asynchronous\r\n        var image = new window.Image();\r\n        image.onerror = function() {\r\n            types[ type ] = false;\r\n            picturefill();\r\n        };\r\n        image.onload = function() {\r\n            types[ type ] = image.width === 1;\r\n            picturefill();\r\n        };\r\n        image.src = typeUri;\r\n        return \"pending\";\r\n    }\r\n\r\n    // test svg support\r\n    types[ \"image/svg+xml\" ] = document.implementation.hasFeature( \"http://wwwindow.w3.org/TR/SVG11/feature#Image\", \"1.1\" );\r\n\r\n    /**\r\n     * updates the internal vW property with the current viewport width in px\r\n     */\r\n    function updateMetrics() {\r\n\r\n        isVwDirty = false;\r\n        DPR = window.devicePixelRatio;\r\n        cssCache = {};\r\n        sizeLengthCache = {};\r\n\r\n        pf.DPR = DPR || 1;\r\n\r\n        units.width = Math.max(window.innerWidth || 0, docElem.clientWidth);\r\n        units.height = Math.max(window.innerHeight || 0, docElem.clientHeight);\r\n\r\n        units.vw = units.width / 100;\r\n        units.vh = units.height / 100;\r\n\r\n        evalId = [ units.height, units.width, DPR ].join(\"-\");\r\n\r\n        units.em = pf.getEmValue();\r\n        units.rem = units.em;\r\n    }\r\n\r\n    function chooseLowRes( lowerValue, higherValue, dprValue, isCached ) {\r\n        var bonusFactor, tooMuch, bonus, meanDensity;\r\n\r\n        //experimental\r\n        if (cfg.algorithm === \"saveData\" ){\r\n            if ( lowerValue > 2.7 ) {\r\n                meanDensity = dprValue + 1;\r\n            } else {\r\n                tooMuch = higherValue - dprValue;\r\n                bonusFactor = Math.pow(lowerValue - 0.6, 1.5);\r\n\r\n                bonus = tooMuch * bonusFactor;\r\n\r\n                if (isCached) {\r\n                    bonus += 0.1 * bonusFactor;\r\n                }\r\n\r\n                meanDensity = lowerValue + bonus;\r\n            }\r\n        } else {\r\n            meanDensity = (dprValue > 1) ?\r\n                Math.sqrt(lowerValue * higherValue) :\r\n                lowerValue;\r\n        }\r\n\r\n        return meanDensity > dprValue;\r\n    }\r\n\r\n    function applyBestCandidate( img ) {\r\n        var srcSetCandidates;\r\n        var matchingSet = pf.getSet( img );\r\n        var evaluated = false;\r\n        if ( matchingSet !== \"pending\" ) {\r\n            evaluated = evalId;\r\n            if ( matchingSet ) {\r\n                srcSetCandidates = pf.setRes( matchingSet );\r\n                pf.applySetCandidate( srcSetCandidates, img );\r\n            }\r\n        }\r\n        img[ pf.ns ].evaled = evaluated;\r\n    }\r\n\r\n    function ascendingSort( a, b ) {\r\n        return a.res - b.res;\r\n    }\r\n\r\n    function setSrcToCur( img, src, set ) {\r\n        var candidate;\r\n        if ( !set && src ) {\r\n            set = img[ pf.ns ].sets;\r\n            set = set && set[set.length - 1];\r\n        }\r\n\r\n        candidate = getCandidateForSrc(src, set);\r\n\r\n        if ( candidate ) {\r\n            src = pf.makeUrl(src);\r\n            img[ pf.ns ].curSrc = src;\r\n            img[ pf.ns ].curCan = candidate;\r\n\r\n            if ( !candidate.res ) {\r\n                setResolution( candidate, candidate.set.sizes );\r\n            }\r\n        }\r\n        return candidate;\r\n    }\r\n\r\n    function getCandidateForSrc( src, set ) {\r\n        var i, candidate, candidates;\r\n        if ( src && set ) {\r\n            candidates = pf.parseSet( set );\r\n            src = pf.makeUrl(src);\r\n            for ( i = 0; i < candidates.length; i++ ) {\r\n                if ( src === pf.makeUrl(candidates[ i ].url) ) {\r\n                    candidate = candidates[ i ];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return candidate;\r\n    }\r\n\r\n    function getAllSourceElements( picture, candidates ) {\r\n        var i, len, source, srcset;\r\n\r\n        // SPEC mismatch intended for size and perf:\r\n        // actually only source elements preceding the img should be used\r\n        // also note: don't use qsa here, because IE8 sometimes doesn't like source as the key part in a selector\r\n        var sources = picture.getElementsByTagName( \"source\" );\r\n\r\n        for ( i = 0, len = sources.length; i < len; i++ ) {\r\n            source = sources[ i ];\r\n            source[ pf.ns ] = true;\r\n            srcset = source.getAttribute( \"srcset\" );\r\n\r\n            // if source does not have a srcset attribute, skip\r\n            if ( srcset ) {\r\n                candidates.push( {\r\n                    srcset: srcset,\r\n                    media: source.getAttribute( \"media\" ),\r\n                    type: source.getAttribute( \"type\" ),\r\n                    sizes: source.getAttribute( \"sizes\" )\r\n                } );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Srcset Parser\r\n     * By Alex Bell |  MIT License\r\n     *\r\n     * @returns Array [{url: _, d: _, w: _, h:_, set:_(????)}, ...]\r\n     *\r\n     * Based super duper closely on the reference algorithm at:\r\n     * https://html.spec.whatwg.org/multipage/embedded-content.html#parse-a-srcset-attribute\r\n     */\r\n\r\n    // 1. Let input be the value passed to this algorithm.\r\n    // (TO-DO : Explain what \"set\" argument is here. Maybe choose a more\r\n    // descriptive & more searchable name.  Since passing the \"set\" in really has\r\n    // nothing to do with parsing proper, I would prefer this assignment eventually\r\n    // go in an external fn.)\r\n    function parseSrcset(input, set) {\r\n\r\n        function collectCharacters(regEx) {\r\n            var chars,\r\n                match = regEx.exec(input.substring(pos));\r\n            if (match) {\r\n                chars = match[ 0 ];\r\n                pos += chars.length;\r\n                return chars;\r\n            }\r\n        }\r\n\r\n        var inputLength = input.length,\r\n            url,\r\n            descriptors,\r\n            currentDescriptor,\r\n            state,\r\n            c,\r\n\r\n            // 2. Let position be a pointer into input, initially pointing at the start\r\n            //    of the string.\r\n            pos = 0,\r\n\r\n            // 3. Let candidates be an initially empty source set.\r\n            candidates = [];\r\n\r\n        /**\r\n        * Adds descriptor properties to a candidate, pushes to the candidates array\r\n        * @return undefined\r\n        */\r\n        // (Declared outside of the while loop so that it's only created once.\r\n        // (This fn is defined before it is used, in order to pass JSHINT.\r\n        // Unfortunately this breaks the sequencing of the spec comments. :/ )\r\n        function parseDescriptors() {\r\n\r\n            // 9. Descriptor parser: Let error be no.\r\n            var pError = false,\r\n\r\n            // 10. Let width be absent.\r\n            // 11. Let density be absent.\r\n            // 12. Let future-compat-h be absent. (We're implementing it now as h)\r\n                w, d, h, i,\r\n                candidate = {},\r\n                desc, lastChar, value, intVal, floatVal;\r\n\r\n            // 13. For each descriptor in descriptors, run the appropriate set of steps\r\n            // from the following list:\r\n            for (i = 0 ; i < descriptors.length; i++) {\r\n                desc = descriptors[ i ];\r\n\r\n                lastChar = desc[ desc.length - 1 ];\r\n                value = desc.substring(0, desc.length - 1);\r\n                intVal = parseInt(value, 10);\r\n                floatVal = parseFloat(value);\r\n\r\n                // If the descriptor consists of a valid non-negative integer followed by\r\n                // a U+0077 LATIN SMALL LETTER W character\r\n                if (regexNonNegativeInteger.test(value) && (lastChar === \"w\")) {\r\n\r\n                    // If width and density are not both absent, then let error be yes.\r\n                    if (w || d) {pError = true;}\r\n\r\n                    // Apply the rules for parsing non-negative integers to the descriptor.\r\n                    // If the result is zero, let error be yes.\r\n                    // Otherwise, let width be the result.\r\n                    if (intVal === 0) {pError = true;} else {w = intVal;}\r\n\r\n                // If the descriptor consists of a valid floating-point number followed by\r\n                // a U+0078 LATIN SMALL LETTER X character\r\n                } else if (regexFloatingPoint.test(value) && (lastChar === \"x\")) {\r\n\r\n                    // If width, density and future-compat-h are not all absent, then let error\r\n                    // be yes.\r\n                    if (w || d || h) {pError = true;}\r\n\r\n                    // Apply the rules for parsing floating-point number values to the descriptor.\r\n                    // If the result is less than zero, let error be yes. Otherwise, let density\r\n                    // be the result.\r\n                    if (floatVal < 0) {pError = true;} else {d = floatVal;}\r\n\r\n                // If the descriptor consists of a valid non-negative integer followed by\r\n                // a U+0068 LATIN SMALL LETTER H character\r\n                } else if (regexNonNegativeInteger.test(value) && (lastChar === \"h\")) {\r\n\r\n                    // If height and density are not both absent, then let error be yes.\r\n                    if (h || d) {pError = true;}\r\n\r\n                    // Apply the rules for parsing non-negative integers to the descriptor.\r\n                    // If the result is zero, let error be yes. Otherwise, let future-compat-h\r\n                    // be the result.\r\n                    if (intVal === 0) {pError = true;} else {h = intVal;}\r\n\r\n                // Anything else, Let error be yes.\r\n                } else {pError = true;}\r\n            } // (close step 13 for loop)\r\n\r\n            // 15. If error is still no, then append a new image source to candidates whose\r\n            // URL is url, associated with a width width if not absent and a pixel\r\n            // density density if not absent. Otherwise, there is a parse error.\r\n            if (!pError) {\r\n                candidate.url = url;\r\n\r\n                if (w) { candidate.w = w;}\r\n                if (d) { candidate.d = d;}\r\n                if (h) { candidate.h = h;}\r\n                if (!h && !d && !w) {candidate.d = 1;}\r\n                if (candidate.d === 1) {set.has1x = true;}\r\n                candidate.set = set;\r\n\r\n                candidates.push(candidate);\r\n            }\r\n        } // (close parseDescriptors fn)\r\n\r\n        /**\r\n        * Tokenizes descriptor properties prior to parsing\r\n        * Returns undefined.\r\n        * (Again, this fn is defined before it is used, in order to pass JSHINT.\r\n        * Unfortunately this breaks the logical sequencing of the spec comments. :/ )\r\n        */\r\n        function tokenize() {\r\n\r\n            // 8.1. Descriptor tokeniser: Skip whitespace\r\n            collectCharacters(regexLeadingSpaces);\r\n\r\n            // 8.2. Let current descriptor be the empty string.\r\n            currentDescriptor = \"\";\r\n\r\n            // 8.3. Let state be in descriptor.\r\n            state = \"in descriptor\";\r\n\r\n            while (true) {\r\n\r\n                // 8.4. Let c be the character at position.\r\n                c = input.charAt(pos);\r\n\r\n                //  Do the following depending on the value of state.\r\n                //  For the purpose of this step, \"EOF\" is a special character representing\r\n                //  that position is past the end of input.\r\n\r\n                // In descriptor\r\n                if (state === \"in descriptor\") {\r\n                    // Do the following, depending on the value of c:\r\n\r\n                  // Space character\r\n                  // If current descriptor is not empty, append current descriptor to\r\n                  // descriptors and let current descriptor be the empty string.\r\n                  // Set state to after descriptor.\r\n                    if (isSpace(c)) {\r\n                        if (currentDescriptor) {\r\n                            descriptors.push(currentDescriptor);\r\n                            currentDescriptor = \"\";\r\n                            state = \"after descriptor\";\r\n                        }\r\n\r\n                    // U+002C COMMA (,)\r\n                    // Advance position to the next character in input. If current descriptor\r\n                    // is not empty, append current descriptor to descriptors. Jump to the step\r\n                    // labeled descriptor parser.\r\n                    } else if (c === \",\") {\r\n                        pos += 1;\r\n                        if (currentDescriptor) {\r\n                            descriptors.push(currentDescriptor);\r\n                        }\r\n                        parseDescriptors();\r\n                        return;\r\n\r\n                    // U+0028 LEFT PARENTHESIS (()\r\n                    // Append c to current descriptor. Set state to in parens.\r\n                    } else if (c === \"\\u0028\") {\r\n                        currentDescriptor = currentDescriptor + c;\r\n                        state = \"in parens\";\r\n\r\n                    // EOF\r\n                    // If current descriptor is not empty, append current descriptor to\r\n                    // descriptors. Jump to the step labeled descriptor parser.\r\n                    } else if (c === \"\") {\r\n                        if (currentDescriptor) {\r\n                            descriptors.push(currentDescriptor);\r\n                        }\r\n                        parseDescriptors();\r\n                        return;\r\n\r\n                    // Anything else\r\n                    // Append c to current descriptor.\r\n                    } else {\r\n                        currentDescriptor = currentDescriptor + c;\r\n                    }\r\n                // (end \"in descriptor\"\r\n\r\n                // In parens\r\n                } else if (state === \"in parens\") {\r\n\r\n                    // U+0029 RIGHT PARENTHESIS ())\r\n                    // Append c to current descriptor. Set state to in descriptor.\r\n                    if (c === \")\") {\r\n                        currentDescriptor = currentDescriptor + c;\r\n                        state = \"in descriptor\";\r\n\r\n                    // EOF\r\n                    // Append current descriptor to descriptors. Jump to the step labeled\r\n                    // descriptor parser.\r\n                    } else if (c === \"\") {\r\n                        descriptors.push(currentDescriptor);\r\n                        parseDescriptors();\r\n                        return;\r\n\r\n                    // Anything else\r\n                    // Append c to current descriptor.\r\n                    } else {\r\n                        currentDescriptor = currentDescriptor + c;\r\n                    }\r\n\r\n                // After descriptor\r\n                } else if (state === \"after descriptor\") {\r\n\r\n                    // Do the following, depending on the value of c:\r\n                    // Space character: Stay in this state.\r\n                    if (isSpace(c)) {\r\n\r\n                    // EOF: Jump to the step labeled descriptor parser.\r\n                    } else if (c === \"\") {\r\n                        parseDescriptors();\r\n                        return;\r\n\r\n                    // Anything else\r\n                    // Set state to in descriptor. Set position to the previous character in input.\r\n                    } else {\r\n                        state = \"in descriptor\";\r\n                        pos -= 1;\r\n\r\n                    }\r\n                }\r\n\r\n                // Advance position to the next character in input.\r\n                pos += 1;\r\n\r\n            // Repeat this step.\r\n            } // (close while true loop)\r\n        }\r\n\r\n        // 4. Splitting loop: Collect a sequence of characters that are space\r\n        //    characters or U+002C COMMA characters. If any U+002C COMMA characters\r\n        //    were collected, that is a parse error.\r\n        while (true) {\r\n            collectCharacters(regexLeadingCommasOrSpaces);\r\n\r\n            // 5. If position is past the end of input, return candidates and abort these steps.\r\n            if (pos >= inputLength) {\r\n                return candidates; // (we're done, this is the sole return path)\r\n            }\r\n\r\n            // 6. Collect a sequence of characters that are not space characters,\r\n            //    and let that be url.\r\n            url = collectCharacters(regexLeadingNotSpaces);\r\n\r\n            // 7. Let descriptors be a new empty list.\r\n            descriptors = [];\r\n\r\n            // 8. If url ends with a U+002C COMMA character (,), follow these substeps:\r\n            //      (1). Remove all trailing U+002C COMMA characters from url. If this removed\r\n            //         more than one character, that is a parse error.\r\n            if (url.slice(-1) === \",\") {\r\n                url = url.replace(regexTrailingCommas, \"\");\r\n                // (Jump ahead to step 9 to skip tokenization and just push the candidate).\r\n                parseDescriptors();\r\n\r\n            //  Otherwise, follow these substeps:\r\n            } else {\r\n                tokenize();\r\n            } // (close else of step 8)\r\n\r\n        // 16. Return to the step labeled splitting loop.\r\n        } // (Close of big while loop.)\r\n    }\r\n\r\n    /*\r\n     * Sizes Parser\r\n     *\r\n     * By Alex Bell |  MIT License\r\n     *\r\n     * Non-strict but accurate and lightweight JS Parser for the string value <img sizes=\"here\">\r\n     *\r\n     * Reference algorithm at:\r\n     * https://html.spec.whatwg.org/multipage/embedded-content.html#parse-a-sizes-attribute\r\n     *\r\n     * Most comments are copied in directly from the spec\r\n     * (except for comments in parens).\r\n     *\r\n     * Grammar is:\r\n     * <source-size-list> = <source-size># [ , <source-size-value> ]? | <source-size-value>\r\n     * <source-size> = <media-condition> <source-size-value>\r\n     * <source-size-value> = <length>\r\n     * http://www.w3.org/html/wg/drafts/html/master/embedded-content.html#attr-img-sizes\r\n     *\r\n     * E.g. \"(max-width: 30em) 100vw, (max-width: 50em) 70vw, 100vw\"\r\n     * or \"(min-width: 30em), calc(30vw - 15px)\" or just \"30vw\"\r\n     *\r\n     * Returns the first valid <css-length> with a media condition that evaluates to true,\r\n     * or \"100vw\" if all valid media conditions evaluate to false.\r\n     *\r\n     */\r\n\r\n    function parseSizes(strValue) {\r\n\r\n        // (Percentage CSS lengths are not allowed in this case, to avoid confusion:\r\n        // https://html.spec.whatwg.org/multipage/embedded-content.html#valid-source-size-list\r\n        // CSS allows a single optional plus or minus sign:\r\n        // http://www.w3.org/TR/CSS2/syndata.html#numbers\r\n        // CSS is ASCII case-insensitive:\r\n        // http://www.w3.org/TR/CSS2/syndata.html#characters )\r\n        // Spec allows exponential notation for <number> type:\r\n        // http://dev.w3.org/csswg/css-values/#numbers\r\n        var regexCssLengthWithUnits = /^(?:[+-]?[0-9]+|[0-9]*\\.[0-9]+)(?:[eE][+-]?[0-9]+)?(?:ch|cm|em|ex|in|mm|pc|pt|px|rem|vh|vmin|vmax|vw)$/i;\r\n\r\n        // (This is a quick and lenient test. Because of optional unlimited-depth internal\r\n        // grouping parens and strict spacing rules, this could get very complicated.)\r\n        var regexCssCalc = /^calc\\((?:[0-9a-z \\.\\+\\-\\*\\/\\(\\)]+)\\)$/i;\r\n\r\n        var i;\r\n        var unparsedSizesList;\r\n        var unparsedSizesListLength;\r\n        var unparsedSize;\r\n        var lastComponentValue;\r\n        var size;\r\n\r\n        // UTILITY FUNCTIONS\r\n\r\n        //  (Toy CSS parser. The goals here are:\r\n        //  1) expansive test coverage without the weight of a full CSS parser.\r\n        //  2) Avoiding regex wherever convenient.\r\n        //  Quick tests: http://jsfiddle.net/gtntL4gr/3/\r\n        //  Returns an array of arrays.)\r\n        function parseComponentValues(str) {\r\n            var chrctr;\r\n            var component = \"\";\r\n            var componentArray = [];\r\n            var listArray = [];\r\n            var parenDepth = 0;\r\n            var pos = 0;\r\n            var inComment = false;\r\n\r\n            function pushComponent() {\r\n                if (component) {\r\n                    componentArray.push(component);\r\n                    component = \"\";\r\n                }\r\n            }\r\n\r\n            function pushComponentArray() {\r\n                if (componentArray[0]) {\r\n                    listArray.push(componentArray);\r\n                    componentArray = [];\r\n                }\r\n            }\r\n\r\n            // (Loop forwards from the beginning of the string.)\r\n            while (true) {\r\n                chrctr = str.charAt(pos);\r\n\r\n                if (chrctr === \"\") { // ( End of string reached.)\r\n                    pushComponent();\r\n                    pushComponentArray();\r\n                    return listArray;\r\n                } else if (inComment) {\r\n                    if ((chrctr === \"*\") && (str[pos + 1] === \"/\")) { // (At end of a comment.)\r\n                        inComment = false;\r\n                        pos += 2;\r\n                        pushComponent();\r\n                        continue;\r\n                    } else {\r\n                        pos += 1; // (Skip all characters inside comments.)\r\n                        continue;\r\n                    }\r\n                } else if (isSpace(chrctr)) {\r\n                    // (If previous character in loop was also a space, or if\r\n                    // at the beginning of the string, do not add space char to\r\n                    // component.)\r\n                    if ( (str.charAt(pos - 1) && isSpace( str.charAt(pos - 1) ) ) || !component ) {\r\n                        pos += 1;\r\n                        continue;\r\n                    } else if (parenDepth === 0) {\r\n                        pushComponent();\r\n                        pos +=1;\r\n                        continue;\r\n                    } else {\r\n                        // (Replace any space character with a plain space for legibility.)\r\n                        chrctr = \" \";\r\n                    }\r\n                } else if (chrctr === \"(\") {\r\n                    parenDepth += 1;\r\n                } else if (chrctr === \")\") {\r\n                    parenDepth -= 1;\r\n                } else if (chrctr === \",\") {\r\n                    pushComponent();\r\n                    pushComponentArray();\r\n                    pos += 1;\r\n                    continue;\r\n                } else if ( (chrctr === \"/\") && (str.charAt(pos + 1) === \"*\") ) {\r\n                    inComment = true;\r\n                    pos += 2;\r\n                    continue;\r\n                }\r\n\r\n                component = component + chrctr;\r\n                pos += 1;\r\n            }\r\n        }\r\n\r\n        function isValidNonNegativeSourceSizeValue(s) {\r\n            if (regexCssLengthWithUnits.test(s) && (parseFloat(s) >= 0)) {return true;}\r\n            if (regexCssCalc.test(s)) {return true;}\r\n            // ( http://www.w3.org/TR/CSS2/syndata.html#numbers says:\r\n            // \"-0 is equivalent to 0 and is not a negative number.\" which means that\r\n            // unitless zero and unitless negative zero must be accepted as special cases.)\r\n            if ((s === \"0\") || (s === \"-0\") || (s === \"+0\")) {return true;}\r\n            return false;\r\n        }\r\n\r\n        // When asked to parse a sizes attribute from an element, parse a\r\n        // comma-separated list of component values from the value of the element's\r\n        // sizes attribute (or the empty string, if the attribute is absent), and let\r\n        // unparsed sizes list be the result.\r\n        // http://dev.w3.org/csswg/css-syntax/#parse-comma-separated-list-of-component-values\r\n\r\n        unparsedSizesList = parseComponentValues(strValue);\r\n        unparsedSizesListLength = unparsedSizesList.length;\r\n\r\n        // For each unparsed size in unparsed sizes list:\r\n        for (i = 0; i < unparsedSizesListLength; i++) {\r\n            unparsedSize = unparsedSizesList[i];\r\n\r\n            // 1. Remove all consecutive <whitespace-token>s from the end of unparsed size.\r\n            // ( parseComponentValues() already omits spaces outside of parens. )\r\n\r\n            // If unparsed size is now empty, that is a parse error; continue to the next\r\n            // iteration of this algorithm.\r\n            // ( parseComponentValues() won't push an empty array. )\r\n\r\n            // 2. If the last component value in unparsed size is a valid non-negative\r\n            // <source-size-value>, let size be its value and remove the component value\r\n            // from unparsed size. Any CSS function other than the calc() function is\r\n            // invalid. Otherwise, there is a parse error; continue to the next iteration\r\n            // of this algorithm.\r\n            // http://dev.w3.org/csswg/css-syntax/#parse-component-value\r\n            lastComponentValue = unparsedSize[unparsedSize.length - 1];\r\n\r\n            if (isValidNonNegativeSourceSizeValue(lastComponentValue)) {\r\n                size = lastComponentValue;\r\n                unparsedSize.pop();\r\n            } else {\r\n                continue;\r\n            }\r\n\r\n            // 3. Remove all consecutive <whitespace-token>s from the end of unparsed\r\n            // size. If unparsed size is now empty, return size and exit this algorithm.\r\n            // If this was not the last item in unparsed sizes list, that is a parse error.\r\n            if (unparsedSize.length === 0) {\r\n                return size;\r\n            }\r\n\r\n            // 4. Parse the remaining component values in unparsed size as a\r\n            // <media-condition>. If it does not parse correctly, or it does parse\r\n            // correctly but the <media-condition> evaluates to false, continue to the\r\n            // next iteration of this algorithm.\r\n            // (Parsing all possible compound media conditions in JS is heavy, complicated,\r\n            // and the payoff is unclear. Is there ever an situation where the\r\n            // media condition parses incorrectly but still somehow evaluates to true?\r\n            // Can we just rely on the browser/polyfill to do it?)\r\n            unparsedSize = unparsedSize.join(\" \");\r\n            if (!(pf.matchesMedia( unparsedSize ) ) ) {\r\n                continue;\r\n            }\r\n\r\n            // 5. Return size and exit this algorithm.\r\n            return size;\r\n        }\r\n\r\n        // If the above algorithm exhausts unparsed sizes list without returning a\r\n        // size value, return 100vw.\r\n        return \"100vw\";\r\n    }\r\n\r\n    // namespace\r\n    pf.ns = (\"pf\" + new Date().getTime()).substr(0, 9);\r\n\r\n    // srcset support test\r\n    pf.supSrcset = \"srcset\" in image;\r\n    pf.supSizes = \"sizes\" in image;\r\n    pf.supPicture = !!window.HTMLPictureElement;\r\n\r\n    if (pf.supSrcset && pf.supPicture && !pf.supSizes) {\r\n        (function(image2) {\r\n            image.srcset = \"data:,a\";\r\n            image2.src = \"data:,a\";\r\n            pf.supSrcset = image.complete === image2.complete;\r\n            pf.supPicture = pf.supSrcset && pf.supPicture;\r\n        })(document.createElement(\"img\"));\r\n    }\r\n\r\n    // using pf.qsa instead of dom traversing does scale much better,\r\n    // especially on sites mixing responsive and non-responsive images\r\n    pf.selShort = \"picture>img,img[srcset]\";\r\n    pf.sel = pf.selShort;\r\n    pf.cfg = cfg;\r\n\r\n    if ( pf.supSrcset ) {\r\n        pf.sel += \",img[\" + srcsetAttr + \"]\";\r\n    }\r\n\r\n    /**\r\n     * Shortcut property for `devicePixelRatio` ( for easy overriding in tests )\r\n     */\r\n    pf.DPR = (DPR  || 1 );\r\n    pf.u = units;\r\n\r\n    // container of supported mime types that one might need to qualify before using\r\n    pf.types =  types;\r\n\r\n    alwaysCheckWDescriptor = pf.supSrcset && !pf.supSizes;\r\n\r\n    pf.setSize = noop;\r\n\r\n    /**\r\n     * Gets a string and returns the absolute URL\r\n     * @param src\r\n     * @returns {String} absolute URL\r\n     */\r\n\r\n    pf.makeUrl = memoize(function(src) {\r\n        anchor.href = src;\r\n        return anchor.href;\r\n    });\r\n\r\n    /**\r\n     * Gets a DOM element or document and a selctor and returns the found matches\r\n     * Can be extended with jQuery/Sizzle for IE7 support\r\n     * @param context\r\n     * @param sel\r\n     * @returns {NodeList}\r\n     */\r\n    pf.qsa = function(context, sel) {\r\n        return context.querySelectorAll(sel);\r\n    };\r\n\r\n    /**\r\n     * Shortcut method for matchMedia ( for easy overriding in tests )\r\n     * wether native or pf.mMQ is used will be decided lazy on first call\r\n     * @returns {boolean}\r\n     */\r\n    pf.matchesMedia = function() {\r\n        if ( window.matchMedia && (matchMedia( \"(min-width: 0.1em)\" ) || {}).matches ) {\r\n            pf.matchesMedia = function( media ) {\r\n                return !media || ( matchMedia( media ).matches );\r\n            };\r\n        } else {\r\n            pf.matchesMedia = pf.mMQ;\r\n        }\r\n\r\n        return pf.matchesMedia.apply( this, arguments );\r\n    };\r\n\r\n    /**\r\n     * A simplified matchMedia implementation for IE8 and IE9\r\n     * handles only min-width/max-width with px or em values\r\n     * @param media\r\n     * @returns {boolean}\r\n     */\r\n    pf.mMQ = function( media ) {\r\n        return media ? evalCSS(media) : true;\r\n    };\r\n\r\n    /**\r\n     * Returns the calculated length in css pixel from the given sourceSizeValue\r\n     * http://dev.w3.org/csswg/css-values-3/#length-value\r\n     * intended Spec mismatches:\r\n     * * Does not check for invalid use of CSS functions\r\n     * * Does handle a computed length of 0 the same as a negative and therefore invalid value\r\n     * @param sourceSizeValue\r\n     * @returns {Number}\r\n     */\r\n    pf.calcLength = function( sourceSizeValue ) {\r\n\r\n        var value = evalCSS(sourceSizeValue, true) || false;\r\n        if (value < 0) {\r\n            value = false;\r\n        }\r\n\r\n        return value;\r\n    };\r\n\r\n    /**\r\n     * Takes a type string and checks if its supported\r\n     */\r\n\r\n    pf.supportsType = function( type ) {\r\n        return ( type ) ? types[ type ] : true;\r\n    };\r\n\r\n    /**\r\n     * Parses a sourceSize into mediaCondition (media) and sourceSizeValue (length)\r\n     * @param sourceSizeStr\r\n     * @returns {*}\r\n     */\r\n    pf.parseSize = memoize(function( sourceSizeStr ) {\r\n        var match = ( sourceSizeStr || \"\" ).match(regSize);\r\n        return {\r\n            media: match && match[1],\r\n            length: match && match[2]\r\n        };\r\n    });\r\n\r\n    pf.parseSet = function( set ) {\r\n        if ( !set.cands ) {\r\n            set.cands = parseSrcset(set.srcset, set);\r\n        }\r\n        return set.cands;\r\n    };\r\n\r\n    /**\r\n     * returns 1em in css px for html/body default size\r\n     * function taken from respondjs\r\n     * @returns {*|number}\r\n     */\r\n    pf.getEmValue = function() {\r\n        var body;\r\n        if ( !eminpx && (body = document.body) ) {\r\n            var div = document.createElement( \"div\" ),\r\n                originalHTMLCSS = docElem.style.cssText,\r\n                originalBodyCSS = body.style.cssText;\r\n\r\n            div.style.cssText = baseStyle;\r\n\r\n            // 1em in a media query is the value of the default font size of the browser\r\n            // reset docElem and body to ensure the correct value is returned\r\n            docElem.style.cssText = fsCss;\r\n            body.style.cssText = fsCss;\r\n\r\n            body.appendChild( div );\r\n            eminpx = div.offsetWidth;\r\n            body.removeChild( div );\r\n\r\n            //also update eminpx before returning\r\n            eminpx = parseFloat( eminpx, 10 );\r\n\r\n            // restore the original values\r\n            docElem.style.cssText = originalHTMLCSS;\r\n            body.style.cssText = originalBodyCSS;\r\n\r\n        }\r\n        return eminpx || 16;\r\n    };\r\n\r\n    /**\r\n     * Takes a string of sizes and returns the width in pixels as a number\r\n     */\r\n    pf.calcListLength = function( sourceSizeListStr ) {\r\n        // Split up source size list, ie ( max-width: 30em ) 100%, ( max-width: 50em ) 50%, 33%\r\n        //\r\n        //                           or (min-width:30em) calc(30% - 15px)\r\n        if ( !(sourceSizeListStr in sizeLengthCache) || cfg.uT ) {\r\n            var winningLength = pf.calcLength( parseSizes( sourceSizeListStr ) );\r\n\r\n            sizeLengthCache[ sourceSizeListStr ] = !winningLength ? units.width : winningLength;\r\n        }\r\n\r\n        return sizeLengthCache[ sourceSizeListStr ];\r\n    };\r\n\r\n    /**\r\n     * Takes a candidate object with a srcset property in the form of url/\r\n     * ex. \"images/pic-medium.png 1x, images/pic-medium-2x.png 2x\" or\r\n     *     \"images/pic-medium.png 400w, images/pic-medium-2x.png 800w\" or\r\n     *     \"images/pic-small.png\"\r\n     * Get an array of image candidates in the form of\r\n     *      {url: \"/foo/bar.png\", resolution: 1}\r\n     * where resolution is http://dev.w3.org/csswg/css-values-3/#resolution-value\r\n     * If sizes is specified, res is calculated\r\n     */\r\n    pf.setRes = function( set ) {\r\n        var candidates;\r\n        if ( set ) {\r\n\r\n            candidates = pf.parseSet( set );\r\n\r\n            for ( var i = 0, len = candidates.length; i < len; i++ ) {\r\n                setResolution( candidates[ i ], set.sizes );\r\n            }\r\n        }\r\n        return candidates;\r\n    };\r\n\r\n    pf.setRes.res = setResolution;\r\n\r\n    pf.applySetCandidate = function( candidates, img ) {\r\n        if ( !candidates.length ) {return;}\r\n        var candidate,\r\n            i,\r\n            j,\r\n            length,\r\n            bestCandidate,\r\n            curSrc,\r\n            curCan,\r\n            candidateSrc,\r\n            abortCurSrc;\r\n\r\n        var imageData = img[ pf.ns ];\r\n        var dpr = pf.DPR;\r\n\r\n        curSrc = imageData.curSrc || img[curSrcProp];\r\n\r\n        curCan = imageData.curCan || setSrcToCur(img, curSrc, candidates[0].set);\r\n\r\n        // if we have a current source, we might either become lazy or give this source some advantage\r\n        if ( curCan && curCan.set === candidates[ 0 ].set ) {\r\n\r\n            // if browser can abort image request and the image has a higher pixel density than needed\r\n            // and this image isn't downloaded yet, we skip next part and try to save bandwidth\r\n            abortCurSrc = (supportAbort && !img.complete && curCan.res - 0.1 > dpr);\r\n\r\n            if ( !abortCurSrc ) {\r\n                curCan.cached = true;\r\n\r\n                // if current candidate is \"best\", \"better\" or \"okay\",\r\n                // set it to bestCandidate\r\n                if ( curCan.res >= dpr ) {\r\n                    bestCandidate = curCan;\r\n                }\r\n            }\r\n        }\r\n\r\n        if ( !bestCandidate ) {\r\n\r\n            candidates.sort( ascendingSort );\r\n\r\n            length = candidates.length;\r\n            bestCandidate = candidates[ length - 1 ];\r\n\r\n            for ( i = 0; i < length; i++ ) {\r\n                candidate = candidates[ i ];\r\n                if ( candidate.res >= dpr ) {\r\n                    j = i - 1;\r\n\r\n                    // we have found the perfect candidate,\r\n                    // but let's improve this a little bit with some assumptions ;-)\r\n                    if (candidates[ j ] &&\r\n                        (abortCurSrc || curSrc !== pf.makeUrl( candidate.url )) &&\r\n                        chooseLowRes(candidates[ j ].res, candidate.res, dpr, candidates[ j ].cached)) {\r\n\r\n                        bestCandidate = candidates[ j ];\r\n\r\n                    } else {\r\n                        bestCandidate = candidate;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if ( bestCandidate ) {\r\n\r\n            candidateSrc = pf.makeUrl( bestCandidate.url );\r\n\r\n            imageData.curSrc = candidateSrc;\r\n            imageData.curCan = bestCandidate;\r\n\r\n            if ( candidateSrc !== curSrc ) {\r\n                pf.setSrc( img, bestCandidate );\r\n            }\r\n            pf.setSize( img );\r\n        }\r\n    };\r\n\r\n    pf.setSrc = function( img, bestCandidate ) {\r\n        var origWidth;\r\n        img.src = bestCandidate.url;\r\n\r\n        // although this is a specific Safari issue, we don't want to take too much different code paths\r\n        if ( bestCandidate.set.type === \"image/svg+xml\" ) {\r\n            origWidth = img.style.width;\r\n            img.style.width = (img.offsetWidth + 1) + \"px\";\r\n\r\n            // next line only should trigger a repaint\r\n            // if... is only done to trick dead code removal\r\n            if ( img.offsetWidth + 1 ) {\r\n                img.style.width = origWidth;\r\n            }\r\n        }\r\n    };\r\n\r\n    pf.getSet = function( img ) {\r\n        var i, set, supportsType;\r\n        var match = false;\r\n        var sets = img [ pf.ns ].sets;\r\n\r\n        for ( i = 0; i < sets.length && !match; i++ ) {\r\n            set = sets[i];\r\n\r\n            if ( !set.srcset || !pf.matchesMedia( set.media ) || !(supportsType = pf.supportsType( set.type )) ) {\r\n                continue;\r\n            }\r\n\r\n            if ( supportsType === \"pending\" ) {\r\n                set = supportsType;\r\n            }\r\n\r\n            match = set;\r\n            break;\r\n        }\r\n\r\n        return match;\r\n    };\r\n\r\n    pf.parseSets = function( element, parent, options ) {\r\n        var srcsetAttribute, imageSet, isWDescripor, srcsetParsed;\r\n\r\n        var hasPicture = parent && parent.nodeName.toUpperCase() === \"PICTURE\";\r\n        var imageData = element[ pf.ns ];\r\n\r\n        if ( imageData.src === undefined || options.src ) {\r\n            imageData.src = getImgAttr.call( element, \"src\" );\r\n            if ( imageData.src ) {\r\n                setImgAttr.call( element, srcAttr, imageData.src );\r\n            } else {\r\n                removeImgAttr.call( element, srcAttr );\r\n            }\r\n        }\r\n\r\n        if ( imageData.srcset === undefined || options.srcset || !pf.supSrcset || element.srcset ) {\r\n            srcsetAttribute = getImgAttr.call( element, \"srcset\" );\r\n            imageData.srcset = srcsetAttribute;\r\n            srcsetParsed = true;\r\n        }\r\n\r\n        imageData.sets = [];\r\n\r\n        if ( hasPicture ) {\r\n            imageData.pic = true;\r\n            getAllSourceElements( parent, imageData.sets );\r\n        }\r\n\r\n        if ( imageData.srcset ) {\r\n            imageSet = {\r\n                srcset: imageData.srcset,\r\n                sizes: getImgAttr.call( element, \"sizes\" )\r\n            };\r\n\r\n            imageData.sets.push( imageSet );\r\n\r\n            isWDescripor = (alwaysCheckWDescriptor || imageData.src) && regWDesc.test(imageData.srcset || \"\");\r\n\r\n            // add normal src as candidate, if source has no w descriptor\r\n            if ( !isWDescripor && imageData.src && !getCandidateForSrc(imageData.src, imageSet) && !imageSet.has1x ) {\r\n                imageSet.srcset += \", \" + imageData.src;\r\n                imageSet.cands.push({\r\n                    url: imageData.src,\r\n                    d: 1,\r\n                    set: imageSet\r\n                });\r\n            }\r\n\r\n        } else if ( imageData.src ) {\r\n            imageData.sets.push( {\r\n                srcset: imageData.src,\r\n                sizes: null\r\n            } );\r\n        }\r\n\r\n        imageData.curCan = null;\r\n        imageData.curSrc = undefined;\r\n\r\n        // if img has picture or the srcset was removed or has a srcset and does not support srcset at all\r\n        // or has a w descriptor (and does not support sizes) set support to false to evaluate\r\n        imageData.supported = !( hasPicture || ( imageSet && !pf.supSrcset ) || isWDescripor );\r\n\r\n        if ( srcsetParsed && pf.supSrcset && !imageData.supported ) {\r\n            if ( srcsetAttribute ) {\r\n                setImgAttr.call( element, srcsetAttr, srcsetAttribute );\r\n                element.srcset = \"\";\r\n            } else {\r\n                removeImgAttr.call( element, srcsetAttr );\r\n            }\r\n        }\r\n\r\n        if (imageData.supported && !imageData.srcset && ((!imageData.src && element.src) ||  element.src !== pf.makeUrl(imageData.src))) {\r\n            if (imageData.src === null) {\r\n                element.removeAttribute(\"src\");\r\n            } else {\r\n                element.src = imageData.src;\r\n            }\r\n        }\r\n\r\n        imageData.parsed = true;\r\n    };\r\n\r\n    pf.fillImg = function(element, options) {\r\n        var imageData;\r\n        var extreme = options.reselect || options.reevaluate;\r\n\r\n        // expando for caching data on the img\r\n        if ( !element[ pf.ns ] ) {\r\n            element[ pf.ns ] = {};\r\n        }\r\n\r\n        imageData = element[ pf.ns ];\r\n\r\n        // if the element has already been evaluated, skip it\r\n        // unless `options.reevaluate` is set to true ( this, for example,\r\n        // is set to true when running `picturefill` on `resize` ).\r\n        if ( !extreme && imageData.evaled === evalId ) {\r\n            return;\r\n        }\r\n\r\n        if ( !imageData.parsed || options.reevaluate ) {\r\n            pf.parseSets( element, element.parentNode, options );\r\n        }\r\n\r\n        if ( !imageData.supported ) {\r\n            applyBestCandidate( element );\r\n        } else {\r\n            imageData.evaled = evalId;\r\n        }\r\n    };\r\n\r\n    pf.setupRun = function() {\r\n        if ( !alreadyRun || isVwDirty || (DPR !== window.devicePixelRatio) ) {\r\n            updateMetrics();\r\n        }\r\n    };\r\n\r\n    // If picture is supported, well, that's awesome.\r\n    if ( pf.supPicture ) {\r\n        picturefill = noop;\r\n        pf.fillImg = noop;\r\n    } else {\r\n\r\n         // Set up picture polyfill by polling the document\r\n        (function() {\r\n            var isDomReady;\r\n            var regReady = window.attachEvent ? /d$|^c/ : /d$|^c|^i/;\r\n\r\n            var run = function() {\r\n                var readyState = document.readyState || \"\";\r\n\r\n                timerId = setTimeout(run, readyState === \"loading\" ? 200 :  999);\r\n                if ( document.body ) {\r\n                    pf.fillImgs();\r\n                    isDomReady = isDomReady || regReady.test(readyState);\r\n                    if ( isDomReady ) {\r\n                        clearTimeout( timerId );\r\n                    }\r\n\r\n                }\r\n            };\r\n\r\n            var timerId = setTimeout(run, document.body ? 9 : 99);\r\n\r\n            // Also attach picturefill on resize and readystatechange\r\n            // http://modernjavascript.blogspot.com/2013/08/building-better-debounce.html\r\n            var debounce = function(func, wait) {\r\n                var timeout, timestamp;\r\n                var later = function() {\r\n                    var last = (new Date()) - timestamp;\r\n\r\n                    if (last < wait) {\r\n                        timeout = setTimeout(later, wait - last);\r\n                    } else {\r\n                        timeout = null;\r\n                        func();\r\n                    }\r\n                };\r\n\r\n                return function() {\r\n                    timestamp = new Date();\r\n\r\n                    if (!timeout) {\r\n                        timeout = setTimeout(later, wait);\r\n                    }\r\n                };\r\n            };\r\n            var lastClientWidth = docElem.clientHeight;\r\n            var onResize = function() {\r\n                isVwDirty = Math.max(window.innerWidth || 0, docElem.clientWidth) !== units.width || docElem.clientHeight !== lastClientWidth;\r\n                lastClientWidth = docElem.clientHeight;\r\n                if ( isVwDirty ) {\r\n                    pf.fillImgs();\r\n                }\r\n            };\r\n\r\n            on( window, \"resize\", debounce(onResize, 99 ) );\r\n            on( document, \"readystatechange\", run );\r\n        })();\r\n    }\r\n\r\n    pf.picturefill = picturefill;\r\n    //use this internally for easy monkey patching/performance testing\r\n    pf.fillImgs = picturefill;\r\n    pf.teardownRun = noop;\r\n\r\n    /* expose methods for testing */\r\n    picturefill._ = pf;\r\n\r\n    window.picturefillCFG = {\r\n        pf: pf,\r\n        push: function(args) {\r\n            var name = args.shift();\r\n            if (typeof pf[name] === \"function\") {\r\n                pf[name].apply(pf, args);\r\n            } else {\r\n                cfg[name] = args[0];\r\n                if (alreadyRun) {\r\n                    pf.fillImgs( { reselect: true } );\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    while (setOptions && setOptions.length) {\r\n        window.picturefillCFG.push(setOptions.shift());\r\n    }\r\n\r\n    /* expose picturefill */\r\n    window.picturefill = picturefill;\r\n\r\n    /* expose picturefill */\r\n    if ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\r\n        // CommonJS, just export\r\n        module.exports = picturefill;\r\n    } else if ( typeof define === \"function\" && define.amd ) {\r\n        // AMD support\r\n        define( \"picturefill\", function() { return picturefill; } );\r\n    }\r\n\r\n    // IE8 evals this sync, so it must be the last thing we do\r\n    if ( !pf.supPicture ) {\r\n        types[ \"image/webp\" ] = detectTypeSupport(\"image/webp\", \"data:image/webp;base64,UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAABBxAR/Q9ERP8DAABWUDggGAAAADABAJ0BKgEAAQADADQlpAADcAD++/1QAA==\" );\r\n    }\r\n\r\n} )( window, document );\r\n","/**\r\n * LAZY SIZES\r\n * @description Lazy loading for images, scripts and iframes\r\n * @see https://github.com/aFarkas/lazysizes\r\n */\r\n\r\n(function(window, factory) {\r\n    var lazySizes = factory(window, window.document);\r\n    window.lazySizes = lazySizes;\r\n    if(typeof module == 'object' && module.exports){\r\n        module.exports = lazySizes;\r\n    } else if (typeof define == 'function' && define.amd) {\r\n        define(lazySizes);\r\n    }\r\n}(window, function(window, document) {\r\n    'use strict';\r\n    /*jshint eqnull:true */\r\n    if(!document.getElementsByClassName){return;}\r\n\r\n    var lazySizesConfig;\r\n\r\n    var docElem = document.documentElement;\r\n\r\n    var supportPicture = window.HTMLPictureElement && ('sizes' in document.createElement('img'));\r\n\r\n    var _addEventListener = 'addEventListener';\r\n\r\n    var addEventListener = window[_addEventListener];\r\n\r\n    var setTimeout = window.setTimeout;\r\n\r\n    var rAF = window.requestAnimationFrame || setTimeout;\r\n\r\n    var regPicture = /^picture$/i;\r\n\r\n    var loadEvents = ['load', 'error', 'lazyincluded', '_lazyloaded'];\r\n\r\n    var regClassCache = {};\r\n\r\n    var forEach = Array.prototype.forEach;\r\n\r\n    var hasClass = function(ele, cls) {\r\n        if(!regClassCache[cls]){\r\n            regClassCache[cls] = new RegExp('(\\\\s|^)'+cls+'(\\\\s|$)');\r\n        }\r\n        return regClassCache[cls].test(ele.className) && regClassCache[cls];\r\n    };\r\n\r\n    var addClass = function(ele, cls) {\r\n        if (!hasClass(ele, cls)){\r\n            ele.className = ele.className.trim() + ' ' + cls;\r\n        }\r\n    };\r\n\r\n    var removeClass = function(ele, cls) {\r\n        var reg;\r\n        if ((reg = hasClass(ele,cls))) {\r\n            ele.className = ele.className.replace(reg, ' ');\r\n        }\r\n    };\r\n\r\n    var addRemoveLoadEvents = function(dom, fn, add){\r\n        var action = add ? _addEventListener : 'removeEventListener';\r\n        if(add){\r\n            addRemoveLoadEvents(dom, fn);\r\n        }\r\n        loadEvents.forEach(function(evt){\r\n            dom[action](evt, fn);\r\n        });\r\n    };\r\n\r\n    var triggerEvent = function(elem, name, detail, noBubbles, noCancelable){\r\n        var event = document.createEvent('CustomEvent');\r\n\r\n        event.initCustomEvent(name, !noBubbles, !noCancelable, detail || {});\r\n\r\n        elem.dispatchEvent(event);\r\n        return event;\r\n    };\r\n\r\n    var updatePolyfill = function (el, full){\r\n        var polyfill;\r\n        if( !supportPicture && ( polyfill = (window.picturefill || lazySizesConfig.pf) ) ){\r\n            polyfill({reevaluate: true, elements: [el]});\r\n        } else if(full && full.src){\r\n            el.src = full.src;\r\n        }\r\n    };\r\n\r\n    var getCSS = function (elem, style){\r\n        return (getComputedStyle(elem, null) || {})[style];\r\n    };\r\n\r\n    var getWidth = function(elem, parent, width){\r\n        width = width || elem.offsetWidth;\r\n\r\n        while(width < lazySizesConfig.minSize && parent && !elem._lazysizesWidth){\r\n            width =  parent.offsetWidth;\r\n            parent = parent.parentNode;\r\n        }\r\n\r\n        return width;\r\n    };\r\n\r\n    var throttle = function(fn){\r\n        var running;\r\n        var lastTime = 0;\r\n        var Date = window.Date;\r\n        var run = function(){\r\n            running = false;\r\n            lastTime = Date.now();\r\n            fn();\r\n        };\r\n        var afterAF = function(){\r\n            setTimeout(run);\r\n        };\r\n        var getAF = function(){\r\n            rAF(afterAF);\r\n        };\r\n\r\n        return function(){\r\n            if(running){\r\n                return;\r\n            }\r\n            var delay = 125 - (Date.now() - lastTime);\r\n\r\n            running =  true;\r\n\r\n            if(delay < 6){\r\n                delay = 6;\r\n            }\r\n            setTimeout(getAF, delay);\r\n        };\r\n    };\r\n\r\n    /*\r\n    var throttle = function(fn){\r\n        var running;\r\n        var lastTime = 0;\r\n        var Date = window.Date;\r\n        var requestIdleCallback = window.requestIdleCallback;\r\n        var gDelay = 125;\r\n        var dTimeout = 999;\r\n        var timeout = dTimeout;\r\n        var run = function(){\r\n            running = false;\r\n            lastTime = Date.now();\r\n            fn();\r\n        };\r\n        var afterAF = function(){\r\n            setImmediate(run);\r\n        };\r\n        var getAF = function(){\r\n            rAF(afterAF);\r\n        };\r\n\r\n        if(requestIdleCallback){\r\n            gDelay = 99;\r\n            getAF = function(){\r\n                requestIdleCallback(run, timeout);\r\n                if(timeout !== dTimeout){\r\n                    timeout = dTimeout;\r\n                }\r\n            };\r\n        }\r\n\r\n        return function(isPriority){\r\n\r\n            if((isPriority = isPriority === true)){\r\n                timeout = 40;\r\n            }\r\n\r\n            if(running){\r\n                return;\r\n            }\r\n            var delay = gDelay - (Date.now() - lastTime);\r\n\r\n            running =  true;\r\n\r\n            if(isPriority || delay < 0){\r\n                getAF();\r\n            } else {\r\n                setTimeout(getAF, delay);\r\n            }\r\n        };\r\n    };\r\n    */\r\n\r\n    var loader = (function(){\r\n        var lazyloadElems, preloadElems, isCompleted, resetPreloadingTimer, loadMode, started;\r\n\r\n        var eLvW, elvH, eLtop, eLleft, eLright, eLbottom;\r\n\r\n        var defaultExpand, preloadExpand;\r\n\r\n        var regImg = /^img$/i;\r\n        var regIframe = /^iframe$/i;\r\n\r\n        var supportScroll = ('onscroll' in window) && !(/glebot/.test(navigator.userAgent));\r\n\r\n        var shrinkExpand = 0;\r\n        var currentExpand = 0;\r\n\r\n        var isLoading = 0;\r\n        var lowRuns = 0;\r\n\r\n        var resetPreloading = function(e){\r\n            isLoading--;\r\n            if(e && e.target){\r\n                addRemoveLoadEvents(e.target, resetPreloading);\r\n            }\r\n\r\n            if(!e || isLoading < 0 || !e.target){\r\n                isLoading = 0;\r\n            }\r\n        };\r\n\r\n        var isNestedVisible = function(elem, elemExpand){\r\n            var outerRect;\r\n            var parent = elem;\r\n            var visible = getCSS(elem, 'visibility') != 'hidden';\r\n\r\n            eLtop -= elemExpand;\r\n            eLbottom += elemExpand;\r\n            eLleft -= elemExpand;\r\n            eLright += elemExpand;\r\n\r\n            while(visible && (parent = parent.offsetParent)){\r\n                visible = ((getCSS(parent, 'opacity') || 1) > 0);\r\n\r\n                if(visible && getCSS(parent, 'overflow') != 'visible'){\r\n                    outerRect = parent.getBoundingClientRect();\r\n                    visible = eLright > outerRect.left &&\r\n                    eLleft < outerRect.right &&\r\n                    eLbottom > outerRect.top - 1 &&\r\n                    eLtop < outerRect.bottom + 1\r\n                    ;\r\n                }\r\n            }\r\n\r\n            return visible;\r\n        };\r\n\r\n        var checkElements = function() {\r\n            var eLlen, i, rect, autoLoadElem, loadedSomething, elemExpand, elemNegativeExpand, elemExpandVal, beforeExpandVal;\r\n\r\n            if((loadMode = lazySizesConfig.loadMode) && isLoading < 8 && (eLlen = lazyloadElems.length)){\r\n\r\n                i = 0;\r\n\r\n                lowRuns++;\r\n\r\n                if(currentExpand < preloadExpand && isLoading < 1 && lowRuns > 3 && loadMode > 2){\r\n                    currentExpand = preloadExpand;\r\n                    lowRuns = 0;\r\n                } else if(loadMode > 1 && lowRuns > 2 && isLoading < 6){\r\n                    currentExpand = defaultExpand;\r\n                } else {\r\n                    currentExpand = shrinkExpand;\r\n                }\r\n\r\n                for(; i < eLlen; i++){\r\n\r\n                    if(!lazyloadElems[i] || lazyloadElems[i]._lazyRace){continue;}\r\n\r\n                    if(!supportScroll){unveilElement(lazyloadElems[i]);continue;}\r\n\r\n                    if(!(elemExpandVal = lazyloadElems[i].getAttribute('data-expand')) || !(elemExpand = elemExpandVal * 1)){\r\n                        elemExpand = currentExpand;\r\n                    }\r\n\r\n                    if(beforeExpandVal !== elemExpand){\r\n                        eLvW = innerWidth + elemExpand;\r\n                        elvH = innerHeight + elemExpand;\r\n                        elemNegativeExpand = elemExpand * -1;\r\n                        beforeExpandVal = elemExpand;\r\n                    }\r\n\r\n                    rect = lazyloadElems[i].getBoundingClientRect();\r\n\r\n                    if ((eLbottom = rect.bottom) >= elemNegativeExpand &&\r\n                        (eLtop = rect.top) <= elvH &&\r\n                        (eLright = rect.right) >= elemNegativeExpand &&\r\n                        (eLleft = rect.left) <= eLvW &&\r\n                        (eLbottom || eLright || eLleft || eLtop) &&\r\n                        ((isCompleted && isLoading < 3 && !elemExpandVal && (loadMode < 3 || lowRuns < 4)) || isNestedVisible(lazyloadElems[i], elemExpand))){\r\n                        unveilElement(lazyloadElems[i]);\r\n                        loadedSomething = true;\r\n                        if(isLoading > 9){break;}\r\n                        if(isLoading > 6){currentExpand = shrinkExpand;}\r\n                    } else if(!loadedSomething && isCompleted && !autoLoadElem &&\r\n                        isLoading < 4 && lowRuns < 4 && loadMode > 2 &&\r\n                        (preloadElems[0] || lazySizesConfig.preloadAfterLoad) &&\r\n                        (preloadElems[0] || (!elemExpandVal && ((eLbottom || eLright || eLleft || eLtop) || lazyloadElems[i].getAttribute(lazySizesConfig.sizesAttr) != 'auto')))){\r\n                        autoLoadElem = preloadElems[0] || lazyloadElems[i];\r\n                    }\r\n                }\r\n\r\n                if(autoLoadElem && !loadedSomething){\r\n                    unveilElement(autoLoadElem);\r\n                }\r\n            }\r\n        };\r\n\r\n        var throttledCheckElements = throttle(checkElements);\r\n\r\n        var switchLoadingClass = function(e){\r\n            addClass(e.target, lazySizesConfig.loadedClass);\r\n            removeClass(e.target, lazySizesConfig.loadingClass);\r\n            addRemoveLoadEvents(e.target, switchLoadingClass);\r\n        };\r\n\r\n        var changeIframeSrc = function(elem, src){\r\n            try {\r\n                elem.contentWindow.location.replace(src);\r\n            } catch(e){\r\n                elem.src = src;\r\n            }\r\n        };\r\n\r\n        var handleSources = function(source){\r\n            var customMedia, parent;\r\n\r\n            var sourceSrcset = source.getAttribute(lazySizesConfig.srcsetAttr);\r\n\r\n            if( (customMedia = lazySizesConfig.customMedia[source.getAttribute('data-media') || source.getAttribute('media')]) ){\r\n                source.setAttribute('media', customMedia);\r\n            }\r\n\r\n            if(sourceSrcset){\r\n                source.setAttribute('srcset', sourceSrcset);\r\n            }\r\n\r\n            if(customMedia){\r\n                parent = source.parentNode;\r\n                parent.insertBefore(source.cloneNode(), source);\r\n                parent.removeChild(source);\r\n            }\r\n        };\r\n\r\n        var rafBatch = (function(){\r\n            var isRunning;\r\n            var batch = [];\r\n            var runBatch = function(){\r\n                while(batch.length){\r\n                    (batch.shift())();\r\n                }\r\n                isRunning = false;\r\n            };\r\n            return function(fn){\r\n                batch.push(fn);\r\n                if(!isRunning){\r\n                    isRunning = true;\r\n                    rAF(runBatch);\r\n                }\r\n            };\r\n        })();\r\n\r\n        var unveilElement = function (elem){\r\n            var src, srcset, parent, isPicture, event, firesLoad, width;\r\n\r\n            var isImg = regImg.test(elem.nodeName);\r\n\r\n            //allow using sizes=\"auto\", but don't use. it's invalid. Use data-sizes=\"auto\" or a valid value for sizes instead (i.e.: sizes=\"80vw\")\r\n            var sizes = isImg && (elem.getAttribute(lazySizesConfig.sizesAttr) || elem.getAttribute('sizes'));\r\n            var isAuto = sizes == 'auto';\r\n\r\n            if( (isAuto || !isCompleted) && isImg && (elem.src || elem.srcset) && !elem.complete && !hasClass(elem, lazySizesConfig.errorClass)){return;}\r\n\r\n            if(isAuto){\r\n                width = elem.offsetWidth;\r\n            }\r\n\r\n            elem._lazyRace = true;\r\n            isLoading++;\r\n\r\n            rafBatch(function lazyUnveil(){\r\n                if(elem._lazyRace){\r\n                    delete elem._lazyRace;\r\n                }\r\n\r\n                removeClass(elem, lazySizesConfig.lazyClass);\r\n\r\n                if(!(event = triggerEvent(elem, 'lazybeforeunveil')).defaultPrevented){\r\n\r\n                    if(sizes){\r\n                        if(isAuto){\r\n                            addClass(elem, lazySizesConfig.autosizesClass);\r\n                            autoSizer.updateElem(elem, true, width);\r\n                        } else {\r\n                            elem.setAttribute('sizes', sizes);\r\n                        }\r\n                    }\r\n\r\n                    srcset = elem.getAttribute(lazySizesConfig.srcsetAttr);\r\n                    src = elem.getAttribute(lazySizesConfig.srcAttr);\r\n\r\n                    if(isImg) {\r\n                        parent = elem.parentNode;\r\n                        isPicture = parent && regPicture.test(parent.nodeName || '');\r\n                    }\r\n\r\n                    firesLoad = event.detail.firesLoad || (('src' in elem) && (srcset || src || isPicture));\r\n\r\n                    event = {target: elem};\r\n\r\n                    if(firesLoad){\r\n                        addRemoveLoadEvents(elem, resetPreloading, true);\r\n                        clearTimeout(resetPreloadingTimer);\r\n                        resetPreloadingTimer = setTimeout(resetPreloading, 2500);\r\n\r\n                        addClass(elem, lazySizesConfig.loadingClass);\r\n                        addRemoveLoadEvents(elem, switchLoadingClass, true);\r\n                    }\r\n\r\n                    if(isPicture){\r\n                        forEach.call(parent.getElementsByTagName('source'), handleSources);\r\n                    }\r\n\r\n                    if(srcset){\r\n                        elem.setAttribute('srcset', srcset);\r\n                    } else if(src && !isPicture){\r\n                        if(regIframe.test(elem.nodeName)){\r\n                            changeIframeSrc(elem, src);\r\n                        } else {\r\n                            elem.src = src;\r\n                        }\r\n                    }\r\n\r\n                    if(srcset || isPicture){\r\n                        updatePolyfill(elem, {src: src});\r\n                    }\r\n                }\r\n\r\n                if( !firesLoad || elem.complete ){\r\n                    if(firesLoad){\r\n                        resetPreloading(event);\r\n                    } else {\r\n                        isLoading--;\r\n                    }\r\n                    switchLoadingClass(event);\r\n                }\r\n            });\r\n        };\r\n\r\n        var onload = function(){\r\n            if(isCompleted){return;}\r\n            if(Date.now() - started < 999){\r\n                setTimeout(onload, 999);\r\n                return;\r\n            }\r\n            var scrollTimer;\r\n            var afterScroll = function(){\r\n                lazySizesConfig.loadMode = 3;\r\n                throttledCheckElements();\r\n            };\r\n\r\n            isCompleted = true;\r\n\r\n            lazySizesConfig.loadMode = 3;\r\n\r\n            if(!isLoading){\r\n                throttledCheckElements();\r\n            }\r\n\r\n            addEventListener('scroll', function(){\r\n                if(lazySizesConfig.loadMode == 3){\r\n                    lazySizesConfig.loadMode = 2;\r\n                }\r\n                clearTimeout(scrollTimer);\r\n                scrollTimer = setTimeout(afterScroll, 99);\r\n            }, true);\r\n        };\r\n\r\n        /*\r\n        var onload = function(){\r\n            var scrollTimer, timestamp;\r\n            var wait = 99;\r\n            var afterScroll = function(){\r\n                var last = (Date.now()) - timestamp;\r\n\r\n                // if the latest call was less that the wait period ago\r\n                // then we reset the timeout to wait for the difference\r\n                if (last < wait) {\r\n                    scrollTimer = setTimeout(afterScroll, wait - last);\r\n\r\n                    // or if not we can null out the timer and run the latest\r\n                } else {\r\n                    scrollTimer = null;\r\n                    lazySizesConfig.loadMode = 3;\r\n                    throttledCheckElements();\r\n                }\r\n            };\r\n\r\n            isCompleted = true;\r\n            lowRuns += 8;\r\n\r\n            lazySizesConfig.loadMode = 3;\r\n\r\n            addEventListener('scroll', function(){\r\n                timestamp = Date.now();\r\n                if(!scrollTimer){\r\n                    lazySizesConfig.loadMode = 2;\r\n                    scrollTimer = setTimeout(afterScroll, wait);\r\n                }\r\n            }, true);\r\n        };\r\n        */\r\n\r\n        return {\r\n            _: function(){\r\n                started = Date.now();\r\n\r\n                lazyloadElems = document.getElementsByClassName(lazySizesConfig.lazyClass);\r\n                preloadElems = document.getElementsByClassName(lazySizesConfig.lazyClass + ' ' + lazySizesConfig.preloadClass);\r\n\r\n                defaultExpand = lazySizesConfig.expand;\r\n                preloadExpand = defaultExpand * lazySizesConfig.expFactor;\r\n\r\n                addEventListener('scroll', throttledCheckElements, true);\r\n\r\n                addEventListener('resize', throttledCheckElements, true);\r\n\r\n                if(window.MutationObserver){\r\n                    new MutationObserver( throttledCheckElements ).observe( docElem, {childList: true, subtree: true, attributes: true} );\r\n                } else {\r\n                    docElem[_addEventListener]('DOMNodeInserted', throttledCheckElements, true);\r\n                    docElem[_addEventListener]('DOMAttrModified', throttledCheckElements, true);\r\n                    setInterval(throttledCheckElements, 999);\r\n                }\r\n\r\n                addEventListener('hashchange', throttledCheckElements, true);\r\n\r\n                //, 'fullscreenchange'\r\n                ['focus', 'mouseover', 'click', 'load', 'transitionend', 'animationend', 'webkitAnimationEnd'].forEach(function(name){\r\n                    document[_addEventListener](name, throttledCheckElements, true);\r\n                });\r\n\r\n                if((/d$|^c/.test(document.readyState))){\r\n                    onload();\r\n                } else {\r\n                    addEventListener('load', onload);\r\n                    document[_addEventListener]('DOMContentLoaded', throttledCheckElements);\r\n                    setTimeout(onload, 20000);\r\n                }\r\n\r\n                throttledCheckElements(lazyloadElems.length > 0);\r\n            },\r\n            checkElems: throttledCheckElements,\r\n            unveil: unveilElement\r\n        };\r\n    })();\r\n\r\n\r\n    var autoSizer = (function(){\r\n        var autosizesElems;\r\n\r\n        var sizeElement = function (elem, dataAttr, width){\r\n            var sources, i, len, event;\r\n            var parent = elem.parentNode;\r\n\r\n            if(parent){\r\n                width = getWidth(elem, parent, width);\r\n                event = triggerEvent(elem, 'lazybeforesizes', {width: width, dataAttr: !!dataAttr});\r\n\r\n                if(!event.defaultPrevented){\r\n                    width = event.detail.width;\r\n\r\n                    if(width && width !== elem._lazysizesWidth){\r\n                        elem._lazysizesWidth = width;\r\n                        width += 'px';\r\n                        elem.setAttribute('sizes', width);\r\n\r\n                        if(regPicture.test(parent.nodeName || '')){\r\n                            sources = parent.getElementsByTagName('source');\r\n                            for(i = 0, len = sources.length; i < len; i++){\r\n                                sources[i].setAttribute('sizes', width);\r\n                            }\r\n                        }\r\n\r\n                        if(!event.detail.dataAttr){\r\n                            updatePolyfill(elem, event.detail);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        var updateElementsSizes = function(){\r\n            var i;\r\n            var len = autosizesElems.length;\r\n            if(len){\r\n                i = 0;\r\n\r\n                for(; i < len; i++){\r\n                    sizeElement(autosizesElems[i]);\r\n                }\r\n            }\r\n        };\r\n\r\n        var throttledUpdateElementsSizes = throttle(updateElementsSizes);\r\n\r\n        return {\r\n            _: function(){\r\n                autosizesElems = document.getElementsByClassName(lazySizesConfig.autosizesClass);\r\n                addEventListener('resize', throttledUpdateElementsSizes);\r\n            },\r\n            checkElems: throttledUpdateElementsSizes,\r\n            updateElem: sizeElement\r\n        };\r\n    })();\r\n\r\n    var init = function(){\r\n        if(!init.i){\r\n            init.i = true;\r\n            autoSizer._();\r\n            loader._();\r\n        }\r\n    };\r\n\r\n    (function(){\r\n        var prop;\r\n\r\n        var lazySizesDefaults = {\r\n            lazyClass: 'lazyload',\r\n            loadedClass: 'lazyloaded',\r\n            loadingClass: 'lazyloading',\r\n            preloadClass: 'lazypreload',\r\n            errorClass: 'lazyerror',\r\n            //strictClass: 'lazystrict',\r\n            autosizesClass: 'lazyautosizes',\r\n            srcAttr: 'data-src',\r\n            srcsetAttr: 'data-srcset',\r\n            sizesAttr: 'data-sizes',\r\n            //preloadAfterLoad: false,\r\n            minSize: 40,\r\n            customMedia: {},\r\n            init: true,\r\n            expFactor: 1.7,\r\n            expand: docElem.clientHeight > 630 ? docElem.clientWidth > 890 ? 500 : 410 : 359,\r\n            loadMode: 2\r\n        };\r\n\r\n        lazySizesConfig = window.lazySizesConfig || window.lazysizesConfig || {};\r\n\r\n        for(prop in lazySizesDefaults){\r\n            if(!(prop in lazySizesConfig)){\r\n                lazySizesConfig[prop] = lazySizesDefaults[prop];\r\n            }\r\n        }\r\n\r\n        window.lazySizesConfig = lazySizesConfig;\r\n\r\n        setTimeout(function(){\r\n            if(lazySizesConfig.init){\r\n                init();\r\n            }\r\n        });\r\n    })();\r\n\r\n    return {\r\n        cfg: lazySizesConfig,\r\n        autoSizer: autoSizer,\r\n        loader: loader,\r\n        init: init,\r\n        uP: updatePolyfill,\r\n        aC: addClass,\r\n        rC: removeClass,\r\n        hC: hasClass,\r\n        fire: triggerEvent,\r\n        gW: getWidth\r\n    };\r\n}));\r\n\r\nwindow.lazySizesConfig.init = false;\r\n","/**\r\n * ZOOM\r\n * @description Zoom image like on Medium\r\n * @see https://github.com/spinningarrow/zoom-vanilla.js/\r\n */\r\n\r\nfunction zoomjs() { \"use strict\";\r\n  var scrollHandlerFn;\r\n  var clickHandlerFn;\r\n  var keyHandlerFn;\r\n  var touchStartFn;\r\n  var touchMoveFn;\r\n\r\n  function offset(element) {\r\n  // From http://www.quirksmode.org/js/findpos.html\r\n  var offset = {\r\n    top: 0,\r\n    left: 0\r\n  }\r\n\r\n  if (!element.offsetParent) return offset\r\n\r\n  do {\r\n    offset.left += element.offsetLeft\r\n    offset.top += element.offsetTop\r\n  } while (element = element.offsetParent)\r\n\r\n  return offset\r\n  }\r\n\r\n  /**\r\n   * The zoom service\r\n   */\r\n  function ZoomService () {\r\n    this._activeZoom            =\r\n    this._initialScrollPosition =\r\n    this._initialTouchPosition  =\r\n    this._touchMoveListener     = null\r\n\r\n    this._document = document\r\n    this._window   = window\r\n    this._body     = document.body\r\n  }\r\n\r\n  ZoomService.prototype.listen = function () {\r\n  document.body.addEventListener('click', function (event) {\r\n    if (event.target.dataset.action === 'zoom') this._zoom(event)\r\n  }.bind(this))\r\n  }\r\n\r\n  ZoomService.prototype._zoom = function (e) {\r\n    var target = e.target\r\n\r\n    if (!target || target.tagName != 'IMG') return\r\n\r\n    if (this._body.classList.contains('zoom-overlay-open')) return\r\n\r\n    if (e.metaKey || e.ctrlKey) {\r\n      return window.open((e.target.getAttribute('data-original') || e.target.src), '_blank')\r\n    }\r\n\r\n    if (target.width >= (window.innerWidth - Zoom.OFFSET)) return\r\n\r\n    this._activeZoomClose(true)\r\n\r\n    this._activeZoom = new Zoom(target)\r\n    this._activeZoom.zoomImage()\r\n\r\n  scrollHandlerFn = this._scrollHandler.bind(this)\r\n  clickHandlerFn = this._clickHandler.bind(this)\r\n  keyHandlerFn = this._keyHandler.bind(this)\r\n  touchStartFn = this._touchStart.bind(this)\r\n\r\n    // todo(fat): probably worth throttling this\r\n  this._window.addEventListener('scroll', scrollHandlerFn)\r\n    this._document.addEventListener('click', clickHandlerFn)\r\n    this._document.addEventListener('keyup', keyHandlerFn)\r\n    this._document.addEventListener('touchstart', touchStartFn)\r\n\r\n    e.stopPropagation()\r\n  }\r\n\r\n  ZoomService.prototype._activeZoomClose = function (forceDispose) {\r\n    if (!this._activeZoom) return\r\n\r\n    if (forceDispose) {\r\n      this._activeZoom.dispose()\r\n    } else {\r\n      this._activeZoom.close()\r\n    }\r\n\r\n  this._window.removeEventListener('scroll', scrollHandlerFn)\r\n    this._document.removeEventListener('click', clickHandlerFn)\r\n    this._document.removeEventListener('keyup', keyHandlerFn)\r\n    this._document.removeEventListener('touchstart', touchStartFn)\r\n\r\n    this._activeZoom = null\r\n  }\r\n\r\n  ZoomService.prototype._scrollHandler = function (e) {\r\n    if (this._initialScrollPosition === null) this._initialScrollPosition = window.scrollY\r\n    var deltaY = this._initialScrollPosition - window.scrollY\r\n    if (Math.abs(deltaY) >= 40) this._activeZoomClose()\r\n  }\r\n\r\n  ZoomService.prototype._keyHandler = function (e) {\r\n    if (e.keyCode == 27) this._activeZoomClose()\r\n  }\r\n\r\n  ZoomService.prototype._clickHandler = function (e) {\r\n    e.stopPropagation()\r\n    e.preventDefault()\r\n    this._activeZoomClose()\r\n  }\r\n\r\n  ZoomService.prototype._touchStart = function (e) {\r\n    this._initialTouchPosition = e.touches[0].pageY\r\n\r\n  touchMoveFn = this._touchMove.bind(this)\r\n  e.target.addEventListener('touchmove', touchMoveFn)\r\n  }\r\n\r\n  ZoomService.prototype._touchMove = function (e) {\r\n    if (Math.abs(e.touches[0].pageY - this._initialTouchPosition) > 10) {\r\n      this._activeZoomClose()\r\n      e.target.removeEventListener('touchmove', touchMoveFn)\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * The zoom object\r\n   */\r\n  function Zoom (img) {\r\n    this._fullHeight      =\r\n    this._fullWidth       =\r\n    this._overlay         =\r\n    this._targetImageWrap = null\r\n\r\n    this._targetImage = img\r\n\r\n    this._body = document.body\r\n  }\r\n\r\n  Zoom.OFFSET = 80\r\n  Zoom._MAX_WIDTH = 2560\r\n  Zoom._MAX_HEIGHT = 4096\r\n\r\n  Zoom.prototype.zoomImage = function () {\r\n    var img = document.createElement('img')\r\n    img.onload = function () {\r\n      this._fullHeight = Number(img.height)\r\n      this._fullWidth = Number(img.width)\r\n      this._zoomOriginal()\r\n    }.bind(this)\r\n    img.src = this._targetImage.src\r\n  }\r\n\r\n  Zoom.prototype._zoomOriginal = function () {\r\n    this._targetImageWrap           = document.createElement('div')\r\n    this._targetImageWrap.className = 'zoom-img-wrap'\r\n\r\n    this._targetImage.parentNode.insertBefore(this._targetImageWrap, this._targetImage)\r\n    this._targetImageWrap.appendChild(this._targetImage)\r\n\r\n    this._targetImage.classList.add('zoom-img')\r\n  this._targetImage.dataset.action = 'zoom-out'\r\n\r\n    this._overlay           = document.createElement('div')\r\n    this._overlay.className = 'zoom-overlay'\r\n\r\n    document.body.appendChild(this._overlay)\r\n\r\n    this._calculateZoom()\r\n    this._triggerAnimation()\r\n  }\r\n\r\n  Zoom.prototype._calculateZoom = function () {\r\n    this._targetImage.offsetWidth // repaint before animating\r\n\r\n    var originalFullImageWidth  = this._fullWidth\r\n    var originalFullImageHeight = this._fullHeight\r\n\r\n    var scrollTop = window.scrollY\r\n\r\n    var maxScaleFactor = originalFullImageWidth / this._targetImage.width\r\n\r\n    var viewportHeight = (window.innerHeight - Zoom.OFFSET)\r\n    var viewportWidth  = (window.innerWidth - Zoom.OFFSET)\r\n\r\n    var imageAspectRatio    = originalFullImageWidth / originalFullImageHeight\r\n    var viewportAspectRatio = viewportWidth / viewportHeight\r\n\r\n    if (originalFullImageWidth < viewportWidth && originalFullImageHeight < viewportHeight) {\r\n      this._imgScaleFactor = maxScaleFactor\r\n\r\n    } else if (imageAspectRatio < viewportAspectRatio) {\r\n      this._imgScaleFactor = (viewportHeight / originalFullImageHeight) * maxScaleFactor\r\n\r\n    } else {\r\n      this._imgScaleFactor = (viewportWidth / originalFullImageWidth) * maxScaleFactor\r\n    }\r\n  }\r\n\r\n  Zoom.prototype._triggerAnimation = function () {\r\n    this._targetImage.offsetWidth // repaint before animating\r\n\r\n  var imageOffset = offset(this._targetImage)\r\n    var scrollTop   = window.scrollY\r\n\r\n    var viewportY = scrollTop + (window.innerHeight / 2)\r\n    var viewportX = (window.innerWidth / 2)\r\n\r\n    var imageCenterY = imageOffset.top + (this._targetImage.height / 2)\r\n    var imageCenterX = imageOffset.left + (this._targetImage.width / 2)\r\n\r\n    this._translateY = viewportY - imageCenterY\r\n    this._translateX = viewportX - imageCenterX\r\n\r\n    this._targetImage.style.transform = 'scale(' + this._imgScaleFactor + ')'\r\n    this._targetImageWrap.style.transform = 'translate(' + this._translateX + 'px, ' + this._translateY + 'px) translateZ(0)'\r\n\r\n    this._body.classList.add('zoom-overlay-open')\r\n  }\r\n\r\n  Zoom.prototype.close = function () {\r\n    this._body.classList.remove('zoom-overlay-open')\r\n    this._body.classList.add('zoom-overlay-transitioning')\r\n\r\n    // we use setStyle here so that the correct vender prefix for transform is used\r\n    this._targetImage.style.transform = ''\r\n    this._targetImageWrap.style.transform = ''\r\n\r\n  this._targetImage.addEventListener('transitionend', this.dispose.bind(this))\r\n  }\r\n\r\n  Zoom.prototype.dispose = function () {\r\n    if (this._targetImageWrap && this._targetImageWrap.parentNode) {\r\n      this._targetImage.classList.remove('zoom-img')\r\n      this._targetImage.dataset.action = 'zoom'\r\n\r\n      this._targetImageWrap.parentNode.replaceChild(this._targetImage, this._targetImageWrap)\r\n      this._overlay.parentNode.removeChild(this._overlay)\r\n\r\n      this._body.classList.remove('zoom-overlay-transitioning')\r\n    }\r\n  }\r\n\r\n  new ZoomService().listen()\r\n\r\n};\r\n","/**\r\n * ASYNC STYLE\r\n * @description Add \"media\" attribute to selected tag relative to \"data-media\". Default is \"all\"\r\n * @see http://keithclark.co.uk/articles/loading-css-without-blocking-render/\r\n * @param DOM el link[rel=\"stylesheet\"] to download\r\n */\r\n\r\nvar asyncStyle = function (element) {\r\n    'use strict';\r\n    \r\n    if (element.media === 'none') {\r\n        element.media = element.getAttribute('data-media') || 'all';\r\n    }\r\n};\r\n","/**\r\n * SCRIPTS\r\n * Use the script\r\n */\r\n\r\n/**\r\n * INCIPIT\r\n * @description Object for manage the application\r\n * @param object extend list of variables\r\n */\r\nfunction Incipit(extend) {\r\n    'use strict';\r\n\r\n    /** Define extend variables */\r\n    var e = extend || {};\r\n\r\n    /**\r\n     * OPTION\r\n     * @description Variables extended by variable extend\r\n     */\r\n    var option = {\r\n        /** string */\r\n        linkSelector: e.linkSelector || 'link[rel=\"stylesheet\"]'\r\n    };\r\n\r\n    /**\r\n     * DOWNLOAD STYLE\r\n     * @description Download all style files\r\n     * @param string stylesheetSelector\r\n     */\r\n    var downloadStyle = function (stylesheetSelector) {\r\n        var DOMstyle = document.querySelectorAll(stylesheetSelector);\r\n\r\n        Array.prototype.forEach.call(DOMstyle, function (element, index) {\r\n            window.addEventListener('load', function () {\r\n                asyncStyle(element);\r\n            }, false);\r\n        });\r\n    };\r\n\r\n    /**\r\n     * PICTUREFILL\r\n     * @description Polyfill for picture tag\r\n     */\r\n    var pictureFill = function () {\r\n        document.createElement('picture');\r\n    };\r\n\r\n    /**\r\n     * INIT\r\n     * @description Functions for init the application\r\n     */\r\n    this.init = function () {\r\n        downloadStyle(option.linkSelector);\r\n        pictureFill();\r\n        zoomjs();\r\n        lazySizes.init();\r\n    };\r\n\r\n    /** INIT */\r\n    this.init();\r\n}\r\n\r\nvar incipit = new Incipit();\r\n"],"sourceRoot":"/source/"}